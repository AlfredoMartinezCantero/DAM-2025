<!doctype html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>EvoSim v1.8.5 - Genetic Legacy</title>
    <style>
        :root {
            --bg: #050508;
            --canvas-bg: #0a0a0f;
            --primary: #00ff88;
            --macho: #00d4ff;
            --hembra: #ff007a;
            --predator: #ff8800;
            --energy: #ffcc00;
            --glass: rgba(15, 15, 25, 0.85);
            --border: rgba(255, 255, 255, 0.1);
        }

        body { 
            margin: 0; background: var(--bg); color: #fff;
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex; flex-direction: column; height: 100vh; overflow: hidden;
        }

        .top-bar {
            background: var(--glass); border-bottom: 1px solid var(--border);
            padding: 10px 30px; display: flex; justify-content: space-between; align-items: center;
            backdrop-filter: blur(15px); z-index: 10;
        }

        .main-view { display: flex; flex: 1; padding: 15px; gap: 15px; }

        .viewport { 
            position: relative; flex: 1; border-radius: 12px; 
            border: 1px solid var(--border); background: var(--canvas-bg);
            overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        canvas#farmCanvas { width: 100%; height: 100%; cursor: crosshair; }

        .panel { width: 280px; display: flex; flex-direction: column; gap: 15px; }
        .card { 
            background: var(--glass); border: 1px solid var(--border);
            border-radius: 10px; padding: 12px;
        }
        .card h3 { margin: 0 0 10px 0; font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1.5px; }

        .stats-grid { display: flex; gap: 25px; }
        .stat-card { display: flex; flex-direction: column; }
        .stat-card span:first-child { font-size: 9px; color: #555; text-transform: uppercase; }
        .stat-card span:last-child { font-size: 20px; font-weight: 800; font-variant-numeric: tabular-nums; }

        .graph-wrapper { height: 80px; }
        canvas.graph-canvas { width: 100%; height: 100%; }

        #status-msg {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0,0,0,0.8); border-left: 3px solid var(--primary);
            padding: 10px 20px; font-size: 12px; color: #fff;
            pointer-events: none; z-index: 100; transition: 0.3s;
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div style="font-weight: 900; letter-spacing: -1px; font-size: 1.4rem;">EVO<span style="color:var(--primary)">SIM</span></div>
        <div class="stats-grid">
            <div class="stat-card"><span>Prey</span><span id="pop" style="color: var(--primary)">0</span></div>
            <div class="stat-card"><span>Males</span><span id="males" style="color: var(--macho)">0</span></div>
            <div class="stat-card"><span>Females</span><span id="females" style="color: var(--hembra)">0</span></div>
            <div class="stat-card"><span>Hunters</span><span id="predators" style="color: var(--predator)">0</span></div>
        </div>
        <div id="day-night" style="font-weight: bold; color: var(--energy)">GENETIC DRIFT ACTIVE</div>
    </div>

    <div class="main-view">
        <div class="viewport">
            <div id="status-msg">SYSTEM STABLE</div>
            <canvas id="farmCanvas"></canvas>
        </div>

        <div class="panel">
            <div class="card">
                <h3>Population Dynamics</h3>
                <div class="graph-wrapper"><canvas id="popGraph" class="graph-canvas"></canvas></div>
            </div>
            <div class="card">
                <h3>Bio-Mass Index</h3>
                <div class="graph-wrapper"><canvas id="resGraph" class="graph-canvas"></canvas></div>
            </div>
            <div class="card" style="flex: 1; background: transparent; border: none;">
                <div id="log" style="font-size: 11px; color: #444; font-family: monospace; line-height: 1.6;">
                    > Waiting for evolutionary events...
                </div>
            </div>
        </div>
    </div>

<script>
const CFG = {
    W: 1200, H: 800,
    INITIAL_ANIMALS: 40, 
    INITIAL_PREDATORS: 3,
    MAX_ANIMALS: 200,
    FOOD_SPAWN_RATE: 2,
    ENERGY_LOSS: 0.15,
    HEALTH_LOSS: 0.4,
    REPRO_COOLDOWN: 400,
    MUTATION_CHANCE: 0.1,
    LERP_SMOOTH: 0.08
};

const lerp = (a, b, t) => a + (b - a) * t;

class Agent {
    constructor(x, y, sex, genes) {
        this.x = x || Math.random() * CFG.W;
        this.y = y || Math.random() * CFG.H;
        this.sex = sex || (Math.random() > 0.5 ? 'M' : 'F');
        // Genes: Velocidad y Rango de visión
        this.genes = genes || { speed: 2.0, sight: 150 };
        this.energy = 100;
        this.health = 100;
        this.angle = Math.random() * Math.PI * 2;
        this.isDead = false;
        this.target = null;
        this.reproCooldown = 100;
    }

    drawBars(ctx, size) {
        const bw = size * 2;
        const bh = 3;
        const py = -size - 12;
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-size, py, bw, bh * 2 + 1);
        ctx.fillStyle = this.health > 40 ? "#00ff88" : "#ff3e3e";
        ctx.fillRect(-size, py, (this.health / 100) * bw, bh);
        ctx.fillStyle = "#ffcc00";
        ctx.fillRect(-size, py + bh + 1, (this.energy / 100) * bw, bh);
    }

    applyBoundaries() {
        if (this.x < 0 || this.x > CFG.W) this.angle = Math.PI - this.angle;
        if (this.y < 0 || this.y > CFG.H) this.angle = -this.angle;
        this.x = Math.max(0, Math.min(CFG.W, this.x));
        this.y = Math.max(0, Math.min(CFG.H, this.y));
    }
}

class Animal extends Agent {
    update() {
        this.energy -= CFG.ENERGY_LOSS;
        if (this.reproCooldown > 0) this.reproCooldown--;
        if (this.energy <= 0) { this.energy = 0; this.health -= CFG.HEALTH_LOSS; }
        if (this.health <= 0) this.isDead = true;

        // IA: Decidir qué buscar
        if (this.energy < 70) {
            this.seekFood();
        } else if (this.reproCooldown <= 0) {
            this.seekPartner();
        }

        if (this.target && !this.target.isDead && !this.target.consumed) {
            let angleTo = Math.atan2(this.target.y - this.y, this.target.x - this.x);
            this.angle = lerp(this.angle, angleTo, CFG.LERP_SMOOTH);
            let dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
            
            if (dist < 10) this.interact(this.target);
        } else {
            this.angle += (Math.random() - 0.5) * 0.15;
            this.target = null;
        }

        this.x += Math.cos(this.angle) * this.genes.speed;
        this.y += Math.sin(this.angle) * this.genes.speed;
        this.applyBoundaries();
    }

    seekFood() {
        if (this.target instanceof Food && !this.target.consumed) return;
        let visibleFood = Engine.foods.filter(f => Math.hypot(f.x-this.x, f.y-this.y) < this.genes.sight);
        if (visibleFood.length > 0) {
            this.target = visibleFood[Math.floor(Math.random() * visibleFood.length)];
        }
    }

    seekPartner() {
        if (this.target instanceof Animal) return;
        let partner = Engine.animals.find(a => 
            a !== this && a.sex !== this.sex && a.reproCooldown <= 0 && a.energy > 70 &&
            Math.hypot(a.x - this.x, a.y - this.y) < this.genes.sight
        );
        if (partner) this.target = partner;
    }

    interact(t) {
        if (t instanceof Food) {
            this.energy = Math.min(100, this.energy + 40);
            t.consumed = true;
            this.target = null;
        } else if (t instanceof Animal && this.sex === 'M') { // Macho inicia reproducción
            this.reproduce(t);
        }
    }

    reproduce(partner) {
        this.reproCooldown = CFG.REPRO_COOLDOWN;
        partner.reproCooldown = CFG.REPRO_COOLDOWN;
        this.energy -= 40;
        partner.energy -= 40;

        // Herencia con mutación
        let childGenes = {
            speed: lerp(this.genes.speed, partner.genes.speed, 0.5) + (Math.random() - 0.5) * CFG.MUTATION_CHANCE * 2,
            sight: lerp(this.genes.sight, partner.genes.sight, 0.5) + (Math.random() - 0.5) * 20
        };

        Engine.spawnQueue.push(new Animal(this.x, this.y, null, childGenes));
        this.target = null;
    }

    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        this.drawBars(ctx, 6);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.sex === 'M' ? '#00d4ff' : '#ff007a';
        ctx.beginPath(); ctx.moveTo(7, 0); ctx.lineTo(-5, 4); ctx.lineTo(-5, -4); ctx.fill();
        ctx.restore();
    }
}

class Predator extends Agent {
    update() {
        this.energy -= CFG.ENERGY_LOSS * 1.5;
        if (this.energy <= 0) { this.energy = 0; this.health -= CFG.HEALTH_LOSS * 2; }
        if (this.health <= 0) this.isDead = true;

        let prey = null;
        let minDist = this.genes.sight;
        Engine.animals.forEach(a => {
            let d = Math.hypot(a.x - this.x, a.y - this.y);
            if (d < minDist) { minDist = d; prey = a; }
        });

        if (prey) {
            let angleTo = Math.atan2(prey.y - this.y, prey.x - this.x);
            this.angle = lerp(this.angle, angleTo, 0.04);
            if (minDist < 12) { prey.isDead = true; this.energy = 100; this.health = 100; }
        } else {
            this.angle += (Math.random() - 0.5) * 0.05;
        }

        this.x += Math.cos(this.angle) * this.genes.speed;
        this.y += Math.sin(this.angle) * this.genes.speed;
        this.applyBoundaries();
    }

    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        this.drawBars(ctx, 10);
        ctx.rotate(this.angle);
        ctx.strokeStyle = '#ff8800'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-8, 7); ctx.lineTo(-4, 0); ctx.lineTo(-8, -7); ctx.closePath(); ctx.stroke();
        ctx.restore();
    }
}

class Food {
    constructor() { this.x = Math.random() * CFG.W; this.y = Math.random() * CFG.H; this.consumed = false; }
    draw(ctx) { ctx.fillStyle = "#00ff88"; ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill(); }
}

class PopulationGraph {
    constructor(id, color) {
        this.canvas = document.getElementById(id);
        this.ctx = this.canvas.getContext('2d');
        this.color = color;
        this.history = new Array(40).fill(0);
        this.lerpValues = new Array(40).fill(0);
    }
    update(val) { this.history.push(val); this.history.shift(); }
    render() {
        let { ctx, canvas, history, lerpValues, color } = this;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let max = Math.max(...history, 10);
        ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
        for (let i = 0; i < history.length; i++) {
            lerpValues[i] = lerp(lerpValues[i], history[i], 0.1);
            let x = (i / (history.length - 1)) * canvas.width;
            let y = canvas.height - (lerpValues[i] / max) * (canvas.height - 10) - 5;
            i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
}

const Engine = {
    animals: [], predators: [], foods: [], spawnQueue: [],
    
    init() {
        this.canvas = document.getElementById("farmCanvas");
        this.ctx = this.canvas.getContext("2d");
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.popGraph = new PopulationGraph('popGraph', '#00ff88');
        this.resGraph = new PopulationGraph('resGraph', '#6e45ff');

        for(let i=0; i<CFG.INITIAL_ANIMALS; i++) this.animals.push(new Animal());
        for(let i=0; i<CFG.INITIAL_PREDATORS; i++) this.predators.push(new Predator(null, null, null, {speed: 2.3, sight: 250}));
        
        setInterval(() => this.statsLoop(), 500);
        this.loop();
    },

    resize() {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
        CFG.W = this.canvas.width; CFG.H = this.canvas.height;
    },

    statsLoop() {
        if (this.foods.length < 150) {
            for(let i=0; i<CFG.FOOD_SPAWN_RATE; i++) this.foods.push(new Food());
        }
        
        // CORRECCIÓN RESPRAWN DEPREDADORES: Verificación constante
        if (this.predators.length === 0 && this.animals.length > 25) {
            this.predators.push(new Predator(null, null, null, {speed: 2.3, sight: 250}));
            this.log("> Predator re-introduced (Prey abundance detected)");
        }

        if (this.animals.length < 5) {
            this.animals.push(new Animal());
            document.getElementById("status-msg").innerText = "RESEEDING PREY...";
            document.getElementById("status-msg").style.color = "#ff3e3e";
        } else {
            document.getElementById("status-msg").innerText = "SYSTEM STABLE";
            document.getElementById("status-msg").style.color = "#00ff88";
        }

        this.popGraph.update(this.animals.length);
        this.resGraph.update(this.foods.length);
    },

    log(msg) {
        const l = document.getElementById("log");
        l.innerHTML = msg + "<br>" + l.innerHTML;
    },

    update() {
        this.animals = this.animals.filter(a => !a.isDead);
        this.predators = this.predators.filter(p => !p.isDead);
        this.foods = this.foods.filter(f => !f.consumed);

        // Incorporar nacimientos
        while(this.spawnQueue.length > 0) {
            this.animals.push(this.spawnQueue.pop());
        }

        this.animals.forEach(a => a.update());
        this.predators.forEach(p => p.update());

        document.getElementById("pop").innerText = this.animals.length;
        document.getElementById("predators").innerText = this.predators.length;
        document.getElementById("males").innerText = this.animals.filter(a=>a.sex==='M').length;
        document.getElementById("females").innerText = this.animals.filter(a=>a.sex==='F').length;
    },

    render() {
        this.ctx.fillStyle = 'rgba(10, 10, 15, 0.4)';
        this.ctx.fillRect(0, 0, CFG.W, CFG.H);
        this.foods.forEach(f => f.draw(this.ctx));
        this.animals.forEach(a => a.draw(this.ctx));
        this.predators.forEach(p => p.draw(this.ctx));
        this.popGraph.render();
        this.resGraph.render();
    },

    loop() {
        this.update(); this.render();
        requestAnimationFrame(() => this.loop());
    }
};

Engine.init();
</script>
</body>
</html>