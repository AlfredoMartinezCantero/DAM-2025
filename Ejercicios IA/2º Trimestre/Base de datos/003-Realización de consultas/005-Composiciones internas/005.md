# Introducción:
En este ejercicio he avanzado en el desarrollo de una API utilizando Flask y MySQL, el primer paso ha sido "crear" la persistencia de datos importando el archivo 001-creo base de datos.sql en mi gestor de base de datos para generar la estructura tiendaclase con las tablas de clientes y productos ya pobladas, el objetivo principal de la parte de programación ha sido darle a la aplicación de capacidad de introspección creando un nuevo `endpoint` en `/tablas`, para ello dentro de la función asociada a la ruta, he instanciado un cursor que ejecuta la sentencia SQL `SHOW TABLES;` como `fetchall()` devuelve una lista de tuplas he tenido que iterar sobre los resultados para extraer solo el nombre de la tabla y guardarlo en una lista limpia, por último, he utilizado `json.dumps` para serializar esa lista y enviarla al navegador con las cabeceras HTTP correctas.

---
```
from flask import Flask, jsonify
import mysql.connector
import json

app = Flask(__name__)

# Configuración de la conexión a la base de datos
conexion = mysql.connector.connect(
    host="localhost",
    user="root",        
    password="tiendaclase123$",        
    database="tiendaclase"
)

@app.route("/")
def inicio():
    return "API de Tienda Clase funcionando"

@app.route("/clientes")
def clientes():
    cursor = conexion.cursor(dictionary=True) # dictionary=True nos devuelve objetos JSON directos
    cursor.execute("SELECT * FROM clientes")
    filas = cursor.fetchall()
    cursor.close()
    return jsonify(filas)

@app.route("/tablas")
def tablas():
    # Creamos el cursor para ejecutar la consulta
    cursor = conexion.cursor() 
    cursor.execute("SHOW TABLES;")  
    
    filas = cursor.fetchall()
    
    # Procesamos la tupla que devuelve MySQL para dejar solo una lista de nombres
    lista_tablas = []
    for fila in filas:
        lista_tablas.append(fila[0])
    
    # Cerramos el cursor para liberar recursos
    cursor.close()
    
    # Devolvemos la lista en formato JSON
    return jsonify(lista_tablas)

if __name__ == "__main__":
    app.run(debug=True)
```
---
# Conclusión:
Con este código se consigue exponer la estructura interna de mi base de datos a través de HTTP, he aprendido a diferenciar entre los datos de negocio como `/clientes` y los metadatos de la base de datos como las `/tablas`, además he comprobado la importancia de transformar los datos crudos que vienen de `cursor.fetchall()` antes de enviarlos al cliente, ya que MySQL devuelve tuplas y el frontend espera una lista de cadenas de texto limpia.

Un error más común y peligroso en este tipo de APIs es olvidar cerrar el cursor con `cursor.close()` antes del return, si dejo el cursor abierto dentro de la función de la ruta, tras muchas peticiones, MySQL rechazará nuevas conexiones por saturación con un mensaje que dice `Too many connections`, tirando el servidor abajo y obligándome a reiniciar el servicio.