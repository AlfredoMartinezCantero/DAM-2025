# Introducción:
Este ejercicio nos ayuda a implementar la "herencia" para evitar la duplicidad de código. He definido una estructura jerárquica donde una clase general define los atributos comunes, y las clases específicas heredan de ella.

He empezado creando la superclase `Cancion`, que actúa como plantilla base, y dos subclases, Extremoduro y Pop, a continuación he utilizado el método constructor `__init__` para inicializar los atributos y la función `super()` para delegar la construcción de la parte común a la clase padre.

---
```
class Cancion:
    #Se define el constructor
    def __init__(self, nombre, artista, duracion):
        self.nombre = nombre
        self.artista = artista
        self.duracion = duracion

    #Devuelvo una cadena con los datos
    def dameDatos(self):
        return f"Canción: {self.nombre} / Artista: {self.artista} / Duración: {self.duracion} min"

class Extremoduro(Cancion):
    def __init__(self, nombre, artista, duracion):
        #Llamo al constructor del padre, en este caso vamos a nombrar Extremoduro "hijo" de la clase "Cancion"
        super().__init__(nombre, artista, duracion)
        self.genero = "Rock"

class Pop(Cancion):
    def __init__(self, nombre, artista, duracion):
        super().__init__(nombre, artista, duracion)
        self.ritmo = "Bailable"

#Creo una instancia de la clase Extremoduro
rock = Extremoduro("So Payaso", "Extremoduro", 4.5)

#Creo una instancia de la clase Pop
pop = Pop("Thriller", "Michael Jackson", 5.2)

#Imprimo la información usando el método heredado
print(rock.dameDatos())
print(pop.dameDatos())
```
---
# Conclusión:
Este código nos ayuda a comprender el funcionamiento de la programación orientada a objetos, gracias al usar `super().__init__`, la subclase aprovecha la asignación de variables de la clase padre `(Cancion)`, permitiendo escribir menos código y mantenerlo más organizado. También la instanciación de objetos específicos, `(tema_rock, tema_pop)`, utilizando sus respectivas clases.

Un error común al trabajar con herencia es pasar `self` como primer argumento dentro de `super().__init__(self, ...)`. Esto es incorrecto y genera un fallo de ejecución, ya que `super()` gestiona el contexto de la instancia automáticamente.