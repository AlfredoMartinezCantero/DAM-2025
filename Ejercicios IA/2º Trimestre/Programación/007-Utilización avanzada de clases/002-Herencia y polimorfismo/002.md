# Introducción
Este ejercicio nos enseña a modelar una estructura de clases para representar a los miembros de un centro educativo. El objetivo principal es entender cómo evitar la duplicidad de código mediante la herencia y cómo modificar el comportamiento de métodos específicos mediante el polimorfismo.

Empezamos creado una clase padre llamada `Persona`. A continuación creamos el constructor `__init__` y utilizo el parámetro `self` para asignar los atributos básicos, `self` es la referencia que hace el objeto a sí mismo para poder guardar sus propios datos en memoria.

A continuación, he implementado las clases hijas `Profesor` y `Alumno`, en estas es donde he aplicado la herencia pasando `Persona` como argumento en la definición de la clase, para a continuación usar el `super().__init__()`, este sirve para llamar al constructor de la clase padre.

En la clase Alumno, al recibir argumentos en el `__init__` (como email o dirección) no sirve de nada si no se guardan, por eso, después de llamar a `super()`, se crea `self.email = email` y `self.direccion = direccion`.

---
```
class Persona:
    def __init__(self, nombre, apellidos):
        self.nombre = nombre
        self.apellidos = apellidos

    def dameDatos(self):
        #Añadimos un espacio para que no se junten ambos textos, sin esto se vería asi: Alfredo MartinezCantero
        return self.nombre + " " + self.apellidos

class Profesor(Persona):
    def __init__(self, nombre, apellidos):
        #Llamamos al constructor del padre para gestionar nombre y apellidos
        super().__init__(nombre, apellidos)

    def dameDatos(self):
        return "Profesor: " + self.nombre + " " + self.apellidos

class Alumno(Persona):
    def __init__(self, nombre, apellidos, email, direccion):
        #Inicializamos la parte común (Persona)
        super().__init__(nombre, apellidos)
        #Inicializamos la parte específica (Alumno)
        self.email = email
        self.direccion = direccion

    def dameDatos(self):
        return "Alumno: " + self.nombre + " " + self.apellidos + " | Email: " + self.email

#Instanciamos un Alumno pasando los 4 argumentos requeridos
alumno1 = Alumno("Alfredo", "Martínez Cantero", "alfredomartinezcantero@gmail.com", "La calle de Alfredo")
print(alumno1.dameDatos())

#Instanciamos un Profesor pasando los 2 argumentos requeridos
profesor1 = Profesor("Jose Vicente", "Carratalá")
print(profesor1.dameDatos())
```
---
# Conclusión:
Este ejercicio nos enseña a crear un sistema escalable donde añadir nuevos roles. También ayuda a comprender el funcionamiento del polimorfismo, el cual permite que el programa principal trate a todos los objetos de forma uniforme (llamando siempre a `dameDatos`), pero obteniendo comportamientos diferentes según el tipo de objeto.

Un error común al hacer este ejercicio ha sido el olvidar la indentación al definir los métodos dentro de una clase. En mi primer intento, definí `dameDatos` del `Profesor` pegado al margen izquierdo, lo que hizo que fuera interpretado como una función global fuera de la clase, rompiendo el polimorfismo.