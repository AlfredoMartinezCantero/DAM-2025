# Introducción:
En este ejercicio he aprendido a dibujar gráficos dinámicos en el navegador utilizando la etiqueta `<canvas>` y su contexto de renderizado en 2D `(getContext("2d"))`, el objetivo ha sido crear un reloj analógico que se actualice en tiempo real, y para lograr el movimiento, he implementado una función llamada `bucle` que actúa como el corazón de la animación, dentro de esta función capturo la hora actual del sistema mediante el objeto `new Date()`, extrayendo las horas, minutos y segundos.

En la parte matemática he tenido que convertir el tiempo en coordenadas (x, y) para saber dónde dibujar la punta de cada manecilla,  he utilizado funciones trigonométricas usando `Math.cos y Math.sin` y he aplicado una corrección de `-Math.PI/2` en el cálculo del ángulo, ya que por defecto el ángulo 0 en un círculo trigonométrico comienza a las 3 en punto, y yo necesitaba que comenzara a las 12 en punto, por último, para mantener la animación viva, he utilizado `setTimeout` creando una recursividad que limpia el lienzo y vuelve a dibujar la escena cada segundo.

---
```
<!doctype html>
<html>
  <head>	
    
  </head>
  <body>
    <canvas></canvas>
    <script>
      // Condiciones iniciales
      let temporizador = setTimeout("bucle()",1000);	
      let lienzo = document.querySelector("canvas");
      lienzo.width = 512;					
      lienzo.height = 512;				
      let contexto = lienzo.getContext("2d"); 
      contexto.lineCap = "round";
      // Condicion de bucle
      function bucle(){
      	let fecha = new Date();						

        let hora = fecha.getHours();			
        let minuto = fecha.getMinutes();	
        let segundo = fecha.getSeconds();	
        
        contexto.clearRect(0,0,512,512); 	
        
        // Ahora dibujo la manecilla de las horas
        contexto.lineWidth = 20;
        contexto.strokeStyle = "blue";
        angulo_hora = hora*(Math.PI*2/12)-Math.PI/2		
        contexto.beginPath(); 			
        contexto.moveTo(256,256);		
        contexto.lineTo(
          256+Math.cos(angulo_hora)*100,
          256+Math.sin(angulo_hora)*100
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los minutos
        contexto.lineWidth = 15;
        contexto.strokeStyle = "green";
        angulo_minuto = minuto*(Math.PI*2/60)-Math.PI/2				
        contexto.beginPath(); 			
        contexto.moveTo(256,256);		
        contexto.lineTo(
          256+Math.cos(angulo_minuto)*150,
          256+Math.sin(angulo_minuto)*150
        )
        contexto.stroke();
        
        // Ahora dibujo la manecilla de los segundos
        contexto.lineWidth = 5;
        contexto.strokeStyle = "red";
        angulo_segundo = segundo*(Math.PI*2/60)-Math.PI/2				
        contexto.beginPath(); 			
        contexto.moveTo(256,256);		
        contexto.lineTo(
          256+Math.cos(angulo_segundo)*200,
          256+Math.sin(angulo_segundo)*200
        )
        contexto.stroke();
        
        // Circulo central
        contexto.beginPath();
        contexto.arc(256,256,50,0,Math.PI*2)
        contexto.fill();
        
        contexto.lineWidth = 25;
        contexto.strokeStyle = "black";
        contexto.beginPath();				
        contexto.arc(256,256,200,0,Math.PI*2) 
        contexto.stroke(); 					

        clearTimeout(temporizador);			
        temporizador = setTimeout("bucle()",1000); 
      }
    </script>
  </body>
</html>
```
---
# Conclusión:
Este código ayuda a comprender sobre cómo funciona una animación por software, he comprendido que el movimiento en pantalla no es mágico, sino que consiste en borrar el lienzo completo y volver a dibujar todos los elementos en sus nuevas posiciones muy rápidamente.

Un error común y que queda mal visualmente en este tipo de ejercicios es olvidar la instrucción `contexto.clearRect(0,0,512,512);` al principio de la función bucle, si omito esta línea, el navegador no borra la posición anterior de las manecillas antes de dibujar las nuevas, lo que provoca que el reloj se llene de "rastros" de pintura, convirtiéndose en una mancha irreconocible tras unos pocos segundos de ejecución.