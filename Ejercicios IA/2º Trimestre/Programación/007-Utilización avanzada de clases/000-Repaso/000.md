# Introducción:
En este ejercicio he desarrollado un backend para un "videojuego" utilizando Python y Flask, donde simulo el comportamiento de personajes no jugables (NPCs) en tiempo real, para lograr esto he definido una clase Npc que actúa como plantilla para cada entidad y he utilizado el método constructor `__init__` para asignar propiedades iniciales aleatorias, como la posición (x, y), el radio y la dirección.

La parte lógica más interesante reside en el método mover, aquí he aplicado trigonometría básica utilizando las funciones `math.cos` y `math.sin` del módulo matemático de Python, esto me permite calcular el desplazamiento en los ejes X e Y basándome en el ángulo de dirección y la velocidad, logrando un movimiento fluido y vectorial en lugar de uno lineal rígido, además introduzco una pequeña variación aleatoria en la dirección en cada actualización para que el movimiento parezca más orgánico.

Por último, he configurado un servidor Flask con dos rutas, siendo estas la raíz / para la vista principal y /api que actúa como un endpoint JSON, este se encarga de actualizar la posición de todos los personajes y devolver su estado actual serializado, permitiendo que un frontend pueda leer estos datos y dibujarlos.

---
```
import math
import random
import json
import pygame
from flask import Flask, render_template

pygame.init()
try:
    pass 
except:
    print("Advertencia: No se encontró el archivo de audio o dispositivo.")

class Npc:
    def __init__(self):
        self.posx = random.randint(0, 800)
        self.posy = random.randint(0, 600)
        self.radio = random.randint(10, 30)
        self.direccion = random.random() * math.pi * 2
        self.velocidad = random.uniform(1, 3)

    def mover(self):
        self.direccion += (random.random() - 0.5) * 0.2
        
        self.posx += math.cos(self.direccion) * self.velocidad
        self.posy += math.sin(self.direccion) * self.velocidad

        if self.posx < 0 or self.posx > 800:
            self.direccion = math.pi - self.direccion
        if self.posy < 0 or self.posy > 600:
            self.direccion = -self.direccion

    def to_dict(self):
        return {
            "x": round(self.posx, 2),
            "y": round(self.posy, 2),
            "radio": self.radio
        }

# Generación de la lista de 50 personajes
personajes = []
for i in range(50):
    personajes.append(Npc())

app = Flask(__name__)

@app.route("/")
def inicio():
    return render_template("juego.html")

@app.route("/api")
def api():
    lista_json = []
    for p in personajes:
        p.mover()
        lista_json.append(p.to_dict())
    
    return json.dumps(lista_json)

if __name__ == "__main__":
    app.run(debug=True)
```
---
# Conclusión:
Con este código he aprendido un poco más el cómo combinar la Programación Orientada a Objetos con el desarrollo web, también puedo mantener el "estado" del juego (la posición de los personajes) en la memoria del servidor Python y exponer esos datos mediante una API JSON, esto separa la lógica de movimiento de la representación visual, permitiendo crear sistemas dinámicos y escalables donde el servidor controla las reglas del juego.