# Introducción:
En este ejercicio he aprendido a modelar información compleja utilizando estructuras de datos anidadas. El objetivo es utilizar un diccionario principal que permita asociar claves descriptivas como "nombre" y "apellidos" con sus valores correspondientes de tipo `str`.

Normalmente un músico suele tiene varios álbumes y el orden cronológico importa, he decidido que el valor de esta clave sea una lista. Dentro de esta lista, se anidan nuevos diccionarios para cada álbum, esto permite estructurar propiedades específicas como `nombre_album (str)` y `año_lanzamiento (int)` de forma encapsulada.

---
```
#Creamos diccionario principal que representa al músico
musico = {
    "nombre": "Roberto",
    "apellidos": "Iniesta",
    "discografia": [
        #Primer elemento de la lista
        {
            "nombre_album": "Rock Transgresivo",
            "año_lanzamiento": 1989
        },
        #Segundo elemento de la lista
        {
            "nombre_album": "Agila",
            "año_lanzamiento": 1996
        },
        #Tercer elemento de la lista
        {
            "nombre_album": "La Ley Innata",
            "año_lanzamiento": 2008
        }
    ]
}

#Imprimimos el diccionario completo para verificar la estructura
print(" ### Estructura Completa ### ")
print(musico)

#Accede e imprimir el nombre del primer álbum
nombre_primer_album = musico["discografia"][0]["nombre_album"]

print("\n### Consulta Específica ###")
print(f"El primer álbum de la lista es: {nombre_primer_album}")
```
---

# Conclusión:
Un error común al trabajar con estructuras anidadas es confundir el orden de acceso o el tipo de paréntesis. He visto que si intento acceder a musico `discografia`, `nombre_album` directamente, Python arrojará un error (TypeError), porque musico `discografia` es una lista y no tiene claves de texto, sino índices numéricos, esto hace que se deba "navegar" capa por capa: primero se entra a la lista con un `índice [0]` y luego al diccionario interno con su clave.