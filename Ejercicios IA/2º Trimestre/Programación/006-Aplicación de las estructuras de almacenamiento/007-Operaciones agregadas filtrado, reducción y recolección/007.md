# Introducción:
En este ejercicio he desarrollado un algoritmo simulando la generación de canciones mediante una aleatoriedad numérica. Para lograrlo, he importado el módulo `random` y he utilizado la función `random.sample`, la cual extrae elementos únicos de una secuencia generada por `range(1, 10)`, garantizando que no haya notas repetidas en la creación.

Para asegurar la integridad de los datos, he implementado una función de validación que transforma las listas en conjuntos matemáticos mediante `set()`. De esta forma, al convertir una lista a set, elimino la dependencia del orden y puedo comparar matemáticamente si la secuencia generada coincide exactamente con mi "molde" de números esperados, independientemente de cómo se hayan desordenado. Finalmente, he encapsulado esta lógica en un bucle para generar una matriz y procesar múltiples canciones en una sola ejecución.

---
```
import random

def genera_cancion():
    #range(1, 10) es como una "baraja" (del 1 al 9)
    #9 es la cantidad de "cartas" que hay que sacar
    return random.sample(range(1, 10), 9)

def es_correcta(cancion):
    #Creo el molde, un conjunto del 1 al 9
    molde = set(range(1, 10))
    
    #Convierto la lista en conjunto (si hay repetidos desaparecen aquí)
    conjunto = set(cancion)
    
    #Si son matemáticamente iguales es True
    return conjunto == molde

def genera_matriz():
    matriz = []
    
    for i in range(10):
        nueva_fila = genera_cancion()
        matriz.append(nueva_fila) #Guardamos la fila
        
    return matriz

canciones = genera_matriz()

print("REVISIÓN DE CANCIONES")
for fila in canciones:
    #Imprimo la lista y el resultado de su validación
    print(f"{fila} -> ¿És válida?: {es_correcta(fila)}")
```
---
# Conclusión:
Con este código he adquirido mejor el conocimiento sobre el manejo de estructuras de datos, comprendiendo la diferencia crucial entre una lista y un conjunto (desordenado y de elementos únicos), además, he reforzado la creación de matrices mediante bucles `for`, entendiendo cómo almacenar estructuras complejas dentro de listas principales para su posterior procesamiento.

Un error común al validar datos es intentar comparar dos listas directamente `lista1 == lista2` cuando el orden es aleatorio. Si no hubiera utilizado `set()`, Python habría comparado la posición `[0]` de una lista con la `[0]` de la otra, y la validación habría fallado aunque los números fueran los correctos.