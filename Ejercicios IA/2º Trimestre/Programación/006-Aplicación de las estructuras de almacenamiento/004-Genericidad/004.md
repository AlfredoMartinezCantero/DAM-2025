# Introducción:
Con este ejercicio he entendido a dar resolución a un problema importante a tener en cuenta, las listas con las que trabajamos no contienen exclusivamente el tipo de dato que esperamos, por lo que intentar realizar operaciones matemáticas directamente sobre todos los elementos provocaría un error del programa.

El objetivo es construir un código capaz de recorrer una lista mixta (enteros y texto) e intentar operar solo con los valores válidos. Para lograrlo, el control de excepciones `try-except` dentro de un bucle. De esta forma forzamos la conversión de los elementos de la lista a un número entero con `int()` para calcular su doble, y en caso de que el dato no sea compatible, capturamos el error de forma controlada para informar al usuario sin detener el programa.

---
```
#Definimos una lista
numeros = [1, 2, 3, 4, "hola", "5", "mundo"]

#Creamos una función para calcular el doble
def calculaDoble(lista):

    #Recorremos cada elemento de la lista
    for elemento in lista:
        try:
            #Intentamos pasar el númer a entero y multiplicarlo por 2
            #Si el elemento no es un número
            resultado = int(elemento)* 2
            print(resultado)
        except:
            #Si falla la conversión el programa mostrará por pantalla "un error"    
            print("El resultado no és válido")
#Por último llamamos a la función
calculaDoble(numeros)
```
---
# Conclusión:
Con este ejercicio aprendemos a cómo procesar listas sin miedo a que el programa colapse. Hemos visto que el bloque `try` actúa como un escudo protector, es decir, aísla el código propenso a fallos con `int()` y deja que el except haga el trabajo de la gestión del error.

Un error común sería el no fijarse bien en cerrar siempre con cuidado el `try-except`. En este ejercicio he usado un `except` genérico sin especificar el tipo de error, esto significa que al no especificar la excepción (ej: ValueError), podrías ocultar errores de programación o del sistema sin darme cuenta.