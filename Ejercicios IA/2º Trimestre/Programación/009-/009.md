# Introducción:
Este ejercicio nos enseña a gestionar conexiones a bases de datos, en este caso he creado una clase llamada `BaseDeDatos` que actúa como una plantilla para instanciar conexiones.

Para empezar, he utilizado `__init__` como constructor, el cual recibe las credenciales y el nombre de la base de datos, asignando atributos de instancia mediante `self.` Esto permite que cada objeto tenga sus propios datos de conexión.

En la lógica interna, he integrado bloques `try-except` dentro del método conectar, fundamental para la conexión a una base de datos, la cual pasa por un proceso propenso a fallos externos (servidor caído, contraseñas incorrectas etc.), y se necesitan capturar esas excepciones para que el programa no se rompa, asi que hacemos que muestre un mensaje de error controlado. Finalmente, el método desconectar verifica si existe una conexión activa antes de intentar cerrarla.

---
```
import sqlite3

class BaseDeDatos:
    def __init__(self, nombre_servidor, base_de_datos, credenciales):
        self.nombre_servidor = nombre_servidor
        self.base_de_datos = base_de_datos
        self.credenciales = credenciales
        self.conexion = None

    def conectar(self):
        try:
            # Simulamos el uso de credenciales y servidor
            print(f"Intentando conectar a {self.base_de_datos} en {self.nombre_servidor}...")
            
            # Establecemos la conexión real
            self.conexion = sqlite3.connect(self.base_de_datos)
            
            print("Conexión establecida con éxito")
            
        except sqlite3.Error as error:
            # Capturamos cualquier error específico de la base de datos
            print(f"Error al conectar: {error}")

    def desconectar(self):
        if self.conexion:
            self.conexion.close()
            print("Conexión cerrada")
        else:
            print("No hay ninguna conexión abierta para cerrar.")

if __name__ == "__main__":
    # Definimos las credenciales
    usuario = "admin"
    password = "123" # No es real para SQLite
    
    # Instanciamos la clase
    mi_db = BaseDeDatos("localhost", "mi_base_prueba.db", (usuario, password))
    
    mi_db.conectar()
    mi_db.desconectar()
```
---
# Conclusión:
Este ejercicio ayuda a comprender que centralizar la lógica de conexión en una clase hace que el código sea más mantenible, si por ejemplo mañana hubiera un cambio de base de datos, solo tengo que modificar esta clase y no todo el programa. Además, se refuerza el uso de self para diferenciar entre variables locales y atributos que persisten durante la vida del objeto.

Un error común es olvidar cerrar la conexión con `desconectar()` o `close()`. Si se dejan las conexiones abiertas, pueden saturar el servidor de base de datos y generar un error "Too many connections", lo que tiraría abajo la aplicación.
También sé que las credenciales nunca deben escribirse directamente en el código en un proyecto real por seguridad.