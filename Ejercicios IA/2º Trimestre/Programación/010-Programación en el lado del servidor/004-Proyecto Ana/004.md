# Introducción:
En este proyecto de clase he creado un IDE Web de python, vamos por partes.

**1.**Configuración del Entorno y Rutas (Backend): Al inicio del script `010-mejoras.py`, mi prioridad ha sido solucionar el problema de la estructura de carpetas. Como he separado el proyecto en back y front, he utilizado la librería `os` y `os.path.abspath('../front/templates')` para indicar explícitamente a Flask dónde buscar los archivos HTML. Sin este bloque, el servidor sería incapaz de renderizar la interfaz visual.

**2.**Persistencia de Datos en Memoria: He definido un diccionario global llamado `sesiones = {}`. Este bloque actúa como una base de datos temporal en la memoria RAM del servidor. Su función es asociar un token con el código que escribe cada usuario, permitiendo que el servidor "recuerde" lo que se ha escrito en peticiones anteriores.

**3.**Los endpoints: La comunicación en tres rutas fundamentales:

    /api/start: Genera un Identificador Único Universal. Es la "llave" que se entrega al navegador para identificar su sesión.

    /api/write: Recibe el código línea a línea mediante POST y lo concatena en el diccionario sesiones. Aquí he aprendido a acumular texto sin ejecutarlo todavía.

    /api/read: Es el detonante. Busca el código asociado al token y lo manda al motor de ejecución.

**4.**El Motor de Ejecución y Captura de Salida: Este es el bloque más complejo y potente. He utilizado `io.StringIO()` para crear una memoria intermedia y he reasignado `sys.stdout` a este buffer. Esto "engaña" a Python, cuando se ejecuta `exec(sesiones[token])`, los `print()` no salen a la consola negra del servidor, sino que se quedan atrapados en mi variable buffer, así puedo capturar el resultado, restaurar la salida normal y enviar el texto al navegador.

**5.**El Frontend, HTML/JS: En lugar de recargar la página entera cada vez que se envía un código, JavaScript hace peticiones "por debajo" al servidor. Además, he añadido bloques `try/catch` para capturar errores de red y mostrar alertas útiles al usuario, mejorando la experiencia de uso.


# Código de Python
---
```
from flask import Flask, render_template, request, jsonify
import sys
import io
import uuid
import os

template_dir = os.path.abspath('../front/templates')
app = Flask(__name__, template_folder=template_dir)

sesiones = {} 

@app.route('/')
def home():
    # Ahora Flask buscará este archivo en la carpeta front/templates
    return render_template('frentemasampliado.html')

@app.route('/api/start')
def start():
    token = str(uuid.uuid4())
    sesiones[token] = "" 
    print(f"--> SESIÓN INICIADA: {token}") 
    return jsonify({"token": token})

@app.route('/api/write', methods=['POST'])
def write():
    datos = request.get_json()
    token = datos.get('token')
    codigo = datos.get('codigo')
    
    if token in sesiones:
        sesiones[token] += codigo + "\n"
        return jsonify({"mensaje": "ok"})
    return jsonify({"mensaje": "error", "causa": "Token invalido"}), 400

@app.route('/api/read', methods=['POST'])
def read():
    datos = request.get_json()
    token = datos.get('token')
    
    if token not in sesiones:
        return jsonify({"salida": "Error: Sesión no encontrada"})

    buffer = io.StringIO()
    sys.stdout = buffer
    
    try:
        exec(sesiones[token])
        resultado = buffer.getvalue()
    except Exception as e:
        resultado = f"Error: {str(e)}"
    finally:
        sys.stdout = sys.__stdout__
    
    return jsonify({"salida": resultado})

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```
---

# Código HTML:
---
```
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Python + Extremoduro IDE</title>
    <style>
        body { font-family: monospace; background: #222; color: #ddd; padding: 20px; }
        .panel { display: flex; gap: 20px; margin-top: 20px;}
        .columna { flex: 1; }
        textarea { width: 100%; height: 200px; background: #111; color: #0f0; border: 1px solid #444; font-size: 14px;}
        #consola { background: #000; color: #fff; padding: 10px; border: 1px solid #666; min-height: 200px; white-space: pre-wrap;}
        button { padding: 10px 20px; background: #d32f2f; color: white; border: none; cursor: pointer; font-size: 16px; margin: 5px 0;}
        button:hover { background: #b71c1c; }
        .musica { background: #333; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;}
        .estado { color: yellow; font-weight: bold; margin-left: 10px;}
    </style>
</head>
<body>

    <div class="musica">
        <h2>Coding Mode: Extremoduro</h2>
        <iframe width="400" height="200" src="https://www.youtube.com/watch?v=OpmrLR9wRAo" title="Extremoduro" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>

    <h1>Intérprete Web Seguro</h1>
    
    <div style="margin-bottom: 20px;">
        <button onclick="iniciar()">1. CONECTAR SERVIDOR (Iniciar Sesión)</button>
        <span id="estado" class="estado">Desconectado</span>
    </div>

    <div class="panel">
        <div class="columna">
            <h3>Entrada de Código</h3>
            <textarea id="codigo" placeholder="Escribe aquí tu código Python..."></textarea>
            <br>
            <button onclick="enviar()">2. Guardar Líneas</button>
            <button onclick="ejecutar()">3. EJECUTAR</button>
        </div>
        <div class="columna">
            <h3>Salida del Servidor</h3>
            <div id="consola">...</div>
        </div>
    </div>

    <script>
        let token = null;

        // PASO 1: Iniciar Sesión con manejo de errores
        async function iniciar() {
            try {
                console.log("Intentando conectar con /api/start...");
                const res = await fetch('/api/start');
                
                if (!res.ok) throw new Error(`Error HTTP: ${res.status}`);
                
                const data = await res.json();
                token = data.token;
                
                document.getElementById('estado').innerText = "CONECTADO";
                document.getElementById('consola').innerText = "Sistema listo. Token: " + token;
                alert("¡Conexión establecida!");
                
            } catch (error) {
                console.error(error);
                alert("ERROR: No se pudo conectar con Python.\n\n1. ¿Has ejecutado 'python 010-mejoras.py'?\n2. ¿Estás en http://127.0.0.1:5000?\n\nDetalle: " + error.message);
            }
        }

        // PASO 2: Enviar
        async function enviar() {
            if(!token) return alert("Primero pulsa el botón 'Conectar Servidor'");
            
            const texto = document.getElementById('codigo').value;
            try {
                await fetch('/api/write', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ token: token, codigo: texto })
                });
                document.getElementById('codigo').value = ""; // Limpiar
                console.log("Línea guardada.");
            } catch (e) {
                alert("Error al enviar código: " + e.message);
            }
        }

        // PASO 3: Ejecutar
        async function ejecutar() {
            if(!token) return alert("Sin conexión.");

            try {
                const res = await fetch('/api/read', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ token: token })
                });
                const data = await res.json();
                document.getElementById('consola').innerText = data.salida;
            } catch (e) {
                alert("Error al leer respuesta: " + e.message);
            }
        }
    </script>
</body>
</html>
```
---
# Conclusión:
Este ejercicio enseña a separar los archivos HTML del código Python, he aprendido que la función `sys.stdout` de Python es redirigible, lo que me ha permitido capturar la salida de `print()` en un buffer de memoria `io.StringIO` para enviársela de vuelta al cliente, también he aprendido el manejo de errores en JavaScript, por ejemplo, ahora sé que un `fetch` debe ir siempre protegido por un bloque `try/catch` para informar al usuario si el servidor no responde, en lugar de dejar la aplicación "congelada".

Un error común que me ha ocurrido es que al reestructurar el proyecto me daba el `Error 500 o 404` por rutas relativas. Al mover el HTML a la carpeta ../front/templates, Flask dejó de encontrar el archivo index.html.