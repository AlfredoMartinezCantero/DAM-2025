# Introducción:
En este ejercicio aprendemos a "entender" al completo un dato, desde su extracción de la base de datos hasta su preparación para el envío a otros sistemas, he trabajado con la librería `mysql.connector`, pero esta vez configurando el cursor con el parámetro `dictionary=True`, lo cual en lugar de recibir tuplas numéricas hace que se obtengan diccionarios que facilitan enormemente la lectura del código.

A nivel de SQL, he aprendido a no traer datos a lo loco con un `SELECT  * ` en su lugar he aplicado proyecciones para seleccionar solo las columnas necesarias y he utilizado un `ORDER BY` para dejar la carga de ordenación al motor de la base de datos.

**Ejercicio 1: Proyección y Ordenación**

---
```
import mysql.connector 

# Conectar a la base de datos
conexion = mysql.connector.connect(
  host="localhost",
  user="clientes",
  password="Clientes123$",
  database="clientes"
)                                      
  
# Creamos el cursor en modo diccionario para acceder por nombre de columna
cursor = conexion.cursor(dictionary=True)

# Ejecutamos la consulta proyectando alias y ordenando
cursor.execute('''
  SELECT
    nombre AS "Nombre del cliente",
    apellidos AS "Apellidos del cliente",
    edad AS "Edad del cliente"
  FROM clientes
  ORDER BY edad DESC;
''')  

# Obtener y mostrar los resultados
filas = cursor.fetchall()

print(filas)

cursor.close()
conexion.close()
```
---
**Ejercicio 2: Resultado como JSON**

---
```
import mysql.connector 
import json

# Conectar a la base de datos
conexion = mysql.connector.connect(
  host="localhost",
  user="clientes",
  password="Clientes123$",
  database="clientes"
)                                      
  
# Es vital usar dictionary=True para que JSON pueda crear los pares clave:valor
cursor = conexion.cursor(dictionary=True)

cursor.execute('''
  SELECT
    nombre AS "Nombre del cliente",
    apellidos AS "Apellidos del cliente",
    edad AS "Edad del cliente"
  FROM clientes
  ORDER BY edad DESC;
''')  

# Obtener los resultados
filas = cursor.fetchall()

# Serializar la lista de diccionarios a texto JSON
json_result = json.dumps(filas, indent=4, ensure_ascii=False)

print(json_result)

cursor.close()
conexion.close()
```
---
# Conclusión:
Con esta actividad he comprobado que el motor de base de datos es el mejor lugar para filtrar y ordenar información, mientras que Python debe encargarse de la lógica de conexión, al crear la exportación a JSON, he comprendiendo que los datos no solo se almacenan, sino que deben formatearse de manera universal para ser útiles en una arquitectura `cliente-servidor`.

Un error común al trabajar con json y bases de datos es la incompatibilidad de tipos, es decir, si intento serializar directamente objetos de tipo `datetime` o `decimal` que devuelve MySQL, el método `json.dumps()` fallará porque no sabe cómo convertirlos a texto, por eso he aprendido que siempre debo convertir esos valores a `str()` o `float()` antes de generar el JSON final.